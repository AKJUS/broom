#' Tidying methods for spatially autoregressive models
#'
#' These methods tidy the coefficients of spatial autoregression
#' models generated by functions of the `spatialreg` package.
#'
#' @param x An object of object returned from [spatialreg::lagsarlm()] or [spatialreg::errorsarlm()].
#' @template param_confint
#' @template param_unused_dots
#' 
#' @examples 
#' library(spatialreg)
#' data(oldcol, package="spdep")
#' listw <- spdep::nb2listw(COL.nb, style="W")
#' 
#' crime_sar <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  
#'   listw=listw, method="eigen")
#'   
#' tidy(crime_sar)
#' tidy(crime_sar, conf.int = TRUE)
#' glance(crime_sar)
#' augment(crime_sar)
#' 
#' crime_sem <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw)
#' 
#' tidy(crime_sem)
#' tidy(crime_sem, conf.int = TRUE)
#' glance(crime_sem)
#' augment(crime_sem)
#' 
#' crime_sac <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw)
#' 
#' tidy.sarlm(crime_sac)
#' tidy.sarlm(crime_sac, conf.int = T)
#' glance.sarlm(crime_sac)
#' augment.sarlm(crime_sac)
#' 
#'
#' 
#' @aliases spatialreg_tidiers
#' @export
#' @family spatialreg tidiers
#' @seealso [tidy()], [spatialreg::lagsarlm()], [spatialreg::errorsarlm()], [spatialreg::sacsarlm()]
tidy.sarlm <- function(x, conf.int = FALSE, conf.level = .95, ...) {
  # construct parameter table
  s <- summary(x)
  ret <- as_tibble(s$Coef, rownames = 'term')
  colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
  
  # append spatial autoregression coefficient to parameter table if it exists
  if (!is.null(s$rho)) {
    rho <- tibble(
        term = "rho",
        estimate = as.numeric(s$rho),
        std.error = as.numeric(s$rho.se),
        statistic = as.numeric(estimate / std.error),
        p.value = as.numeric(2 * (1 - pnorm( abs(statistic) ) ) )
      )
    ret <- bind_rows(rho, ret)
  }
  
  # append spatial error coefficient to parameter table if it exists
  if (!is.null(s$lambda))  {
    lambda <- tibble(
      term = "lambda",
      estimate = as.numeric(s$lambda),
      std.error = as.numeric(s$lambda.se),
      statistic = as.numeric(estimate / std.error),
      p.value = as.numeric(2 * (1 - pnorm( abs(statistic) ) ) )
    )
    ret <- bind_rows(ret, lambda)
  }
  
  
  
  # Calculate confidence interval
  if (conf.int) {
    ci <- confint(x, level = conf.level)
    ci <- as_tibble(ci, rownames = "term")
    colnames(ci) <- c("term", "conf.low", "conf.high")
    ret <- dplyr::left_join(ret, ci, by = "term")
  }
  
  ret
}
#' @templateVar class spatialreg
#' @template title_desc_augment
#'
#' @template augment_NAs
#'
#' @inherit tidy.sarlm params examples
#'
#' @export
#' @seealso [augment()]
#' @family spatialreg tidiers
augment.sarlm <- function(x) {
  
  reg <- as_tibble(x$X) %>%
    select(-1) %>%
    dplyr::mutate(
      y = x$y,
      .fitted = x$fitted.values, 
      .resid = x$residuals
    )
  
  #TODO: Extend for spatial lags of variables
  
  reg
  
}


#' @templateVar class spatialreg
#' @template title_desc_glance
#' 
#' @inherit tidy.sarlm params examples
#' 
#' @evalRd return_glance("logLik", "AIC", "BIC", "deviance", "logLik", "nobs")
#' @export
#' @family spatialreg tidiers
#' @seealso [glance()], [spatialreg::lagsarlm()], [spatialreg::errorsarlm()], [spatialreg::sacsarlm()]
glance.sarlm <- function(x) {
  
  res <- tibble(
      # Using Pseudo R squared.
      r.squared = cor(x$fitted.values, x$y)^2,
      AIC = stats::AIC(x),
      BIC = stats::BIC(x),
      deviance = stats::deviance(x),
      logLik = as.numeric(x$LL),
      nobs = length(x$fitted.values)
    )
  
  res
}

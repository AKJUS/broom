<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction to broom}
-->

```{r setup, echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, warning=FALSE, message=FALSE)
```

The `broom` package: let's tidy up a bit
========================================

The concept of "tidy data", [as introduced by Hadley Wickham](http://vita.had.co.nz/papers/tidy-data.html), is a powerful philosophy for data manipulation and analysis. Wickham's paper on Tidy Data makes a convincing statement of the problem this package tries to solve (emphasis mine):

> **While model inputs usually require tidy inputs, such attention to detail doesn't carry over to model outputs. Outputs such as predictions and estimated coefficients aren't always tidy. This makes it more difficult to combine results from multiple models.** For example, in R, the default representation of model coefficients is not tidy because it does not have an explicit variable that records the variable name for each estimate, they are instead recorded as row names. In R, row names must be unique, so combining coefficients from many models (e.g., from bootstrap resamples, or subgroups) requires workarounds to avoid losing important information. **This knocks you out of the flow of analysis and makes it harder to combine the results from multiple models. I'm not currently aware of any packages that resolve this problem.**

`broom` is an attempt to bridge the gap from untidy outputs of predictions and estimations to the tidy data we want.

Examples
--------

```{r import_broom}
library(broom)
```

```{r lmfit, dependson="import_broom"}
lmfit = lm(mpg ~ wt, mtcars)
lmfit
summary(lmfit)
```

```{r, dependson="lmfit"}
tidy(lmfit)
```

```{r glmfit, dependson="import_broom"}
glmfit = glm(am ~ wt, mtcars, family="binomial")
tidy(glmfit)
```


```{r ttest, dependson="import_broom"}
tt = t.test(wt ~ am, mtcars)
tidy(tt)
```

```{r wtest, dependson="import_broom"}
wt = wilcox.test(wt ~ am, mtcars)
tidy(wt)
```

*TODO*: more here
